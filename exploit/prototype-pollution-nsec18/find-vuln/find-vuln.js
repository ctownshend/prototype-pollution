var process = require("process");
var parsedObject = [];
var polluted = [];
var functions = [];

function check(fnct, sig, name, totest) {
  console.log({}.test, name, totest);
  if ({}.test == "123" || {}.test == 123) {
    delete Object.prototype.test;
    return true;
  }
  return false;
}

function run(fnct, sig, name, totest) {
  // Reinitialize to avoid issue if the previous function changed attributes.
  BAD_JSON = JSON.parse('{"__proto__":{"test":123}}');

  try {
    let res = fnct(totest);
    // console.log(name);
    // if (name.search("clone") >= 0) {
    // 	console.log("HERE", {}, res);
    // }
  } catch (e) {return}

  let test = check(fnct, sig, name, totest);
  if (test) {
    console.log("Detected : " + name + " (" + sig + ")");
    item = {
      name: name,
      fnct: fnct,
      sig: sig,
      totest: totest,
      functionName: totest.name,
    };

    uniqueAddSig(polluted, item);
  }
}

var BAD_JSON = {};
var args = process.argv.slice(2);

process.on("uncaughtException", function (err) {});

var pattern = [
  {
    fnct: function (totest) {
      totest(BAD_JSON);
    },
    sig: "function (BAD_JSON)",
  },
  {
    fnct: function (totest) {
      totest(BAD_JSON, {});
    },
    sig: "function (BAD_JSON, {})",
  },
  {
    fnct: function (totest) {
      totest({}, BAD_JSON);
    },
    sig: "function ({}, BAD_JSON)",
  },
  {
    fnct: function (totest) {
      totest(BAD_JSON, BAD_JSON);
    },
    sig: "function (BAD_JSON, BAD_JSON)",
  },
  {
    fnct: function (totest) {
      totest({}, {}, BAD_JSON);
    },
    sig: "function ({}, {}, BAD_JSON)",
  },
  {
    fnct: function (totest) {
      totest({}, {}, {}, BAD_JSON);
    },
    sig: "function ({}, {}, {}, BAD_JSON)",
  },
  {
    fnct: function (totest) {
      totest({}, "__proto__.test", "123");
    },
    sig: "function ({__proto__.test}, BAD_PATH, VALUE)",
  },
  {
    fnct: function (totest) {
      totest({}, "__proto__[test]", "123");
    },
    sig: "function ({__proto__[test]}, BAD_PATH, VALUE)",
  },
  {
    fnct: function (totest) {
      totest("__proto__.test", "123");
    },
    sig: "function (BAD_PATH, VALUE)",
  },
  {
    fnct: function (totest) {
      totest("__proto__[test]", "123");
    },
    sig: "function (BAD_PATH[TEST], VALUE)",
  },
  {
    fnct: function (totest) {
      totest({}, "__proto__", "test", "123");
    },
    sig: "function ({}, BAD_STRING, BAD_STRING, VALUE) __proto__, test, 123",
  },
  ,
  {
    fnct: function (totest) {
      totest(["__proto__.test"], ["123"]);
    },
    sig: "function ([BAD_STRING], [VALUE])",
  },
  //cam test
  // {
  //   fnct: function (totest) {
  //     return totest(BAD_JSON);
  //   },
  //   sig: "return function (BAD_JSON)",
  // },
];

function exploreLib(lib, prefix, depth) {
  if (depth == 0) return;
  if (parsedObject.indexOf(lib) !== -1) return;
  uniqueAdd(parsedObject, lib);
  // parsedObject.push(lib);
  // console.dir(parsedObject);
  for (var k in lib) {
    if (k == "abort") continue;
    if (k == "__proto__") continue;
    if (+k == k) continue;

    console.log(k);
    uniqueAdd(functions, k);
    if (lib.hasOwnProperty(k)) {
      for (p in pattern) {
        if (pattern.hasOwnProperty(p)) {
          run(pattern[p].fnct, pattern[p].sig, prefix + "." + k, lib[k]);
        }
      }
      exploreLib(lib[k], prefix + "." + k, depth - 1);
    }
  }

  if (typeof lib == "function") {
    for (p in pattern) {
      if (pattern.hasOwnProperty(p)) {
        // console.log(
        //   "pattern[p].fnct, pattern[p].sig, args[0], lib",
        //   pattern[p].fnct,
        //   pattern[p].sig,
        //   args[0],
        //   lib
        // );
        run(pattern[p].fnct, pattern[p].sig, args[0], lib);
      }
    }
  }
  return { polluted: polluted, functions: functions };
}

function Analyse(packageName) {
  try {
    var lib = require(packageName);
    console.log(lib.VERSION);
    var pollution = exploreLib(lib, packageName, 5);
    console.log("pollution", pollution);
    return pollution;
  } catch (e) {
    console.log("Missing library : " + args[0]);
    return;
  }
}

// if (args.length < 1) {
//   console.log("First argument must be the library name");
//   exit();
// }
function uniqueAdd(arr, item) {
  
  if (arr.indexOf(item) === -1) {
    arr.push(item);
    // console.log(arr);
  }
}

function uniqueAddSig(arr, items) {
  if (
    arr.filter((arrItem) => {
      return (arrItem.sig === item.sig && arrItem.functionName === item.functionName)
    }).length === 0
  ) {
    arr.push(item);
  }
  // if (arr.indexOf(item) === -1) {
  //   arr.push(item);
  //   // console.log(arr);
  // }
}

function sigmatcher(item, sig, functionName) {
  return item.sig === sig && item.functionName === functionName;
}
module.exports = Analyse;

// module.exports = polluted;
