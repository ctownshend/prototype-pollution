// var foo = require("/Users/camerontownshend/Documents/Cameron/dev/learnVulnerabilities/prototype-pollution/exploit/prototype-pollution-nsec18/find-vuln/find-vuln.js");
// console.dir(foo ("/Users/camerontownshend/Documents/Cameron/dev/learnVulnerabilities/prototype-pollution/npm_libraries/lodash/v4.17.4/node_modules/lodash"));
// node /Users/camerontownshend/Documents/Cameron/dev/learnVulnerabilities/prototype-pollution/exploit/prototype-pollution-nsec18/find-vuln/find-vuln.js /Users/camerontownshend/Documents/Cameron/dev/learnVulnerabilities/prototype-pollution/npm_libraries/lodash/v4.17.4/node_modules/lodash

const pg = require("pg");

const pool = new pg.Pool({
  user: "iq-server",
  host: "postgres",
  database: "fuzzy",
  password: "xxxxxx",
  port: "5432",
});

async function tearDown() {
  pool.end();
}

async function insertPackage(format, packagename, description) {
  return new Promise((resolve, reject) => {
    let packageid;
    let dateAdded = datePGFormat(new Date().getTime());
    let sqlString =
      "; INSERT INTO package(format, packagename, dateadded, description) ";
    description = description.replace(/'/g, "");
    sqlString += ` Values ('${format}', '${packagename}', '${dateAdded}', '${description}' )`;
    sqlString += ` ON CONFLICT (format, packagename) do UPDATE set dateadded = '${dateAdded}', description = '${description}'`;
    sqlString += " RETURNING packageid;";
    //return
    pool.query(sqlString, (err, res) => {
      // console.log(err, res);
      if (err) {
        reject(err);
      } else if (res) {
        // console.log("row0", res.rows[0].packageid);
        packageid = res.rows[0].packageid;
      }
      resolve(packageid);
    });
  });
}

async function insertPV(packageid, packageRelease) {
  return new Promise((resolve, reject) => {
    console.log(
      " insertPV packageid, packageRelease",
      packageid,
      packageRelease
    );
    let packageversionid;
    let dateAdded = datePGFormat(new Date().getTime());
    let sqlString =
      "; INSERT INTO packageversion(packageid, version, datepublished, dateadded) ";
    sqlString += ` Values ('${packageid}', '${packageRelease.version}', '${packageRelease.datePublished}', '${dateAdded}' )`;
    sqlString += ` ON CONFLICT (packageid, version) do UPDATE set dateadded = '${dateAdded}'`;
    sqlString += " RETURNING packageversionid;";
    console.log(sqlString);
    //return
    pool.query(sqlString, (err, res) => {
      // console.log(err, res);
      if (err) {
        reject(err);
      }
      packageversionid = res.rows[0].packageversionid;
      resolve(packageversionid);
    });
  });
}

async function insertPVF(packageversionid, functionname) {
  return new Promise((resolve, reject) => {
    let packageversionfunctionid;
    let dateAdded = datePGFormat(new Date().getTime());
    let sqlString =
      "; INSERT INTO packageversionfunction(packageversionid, functionname, dateadded) ";
    sqlString += ` Values ('${packageversionid}', '${functionname}', '${dateAdded}' )`;
    sqlString += ` ON CONFLICT (packageversionid, functionname) do UPDATE set dateadded = '${dateAdded}'`;
    sqlString += " RETURNING packageversionfunctionid;";
    console.log(sqlString);
    //return
    pool.query(sqlString, (err, res) => {
      // console.log(err, res);
      if (err) {
        console.log("functionname", functionname);
        reject(err);
      }
      if (res ) {
        packageversionfunctionid = res.rows[0].packageversionfunctionid;
      }
      console.log(
        "packageversionfunctionid insertPVF result",
        packageversionfunctionid
      );
      resolve(packageversionfunctionid);
    });
  });
}

async function insertPVFV(
  packageversionfunctionid,
  vulnerability,
  vulnerabilitypoc,
  cwe,
  cves
) {
  return new Promise((resolve, reject) => {
    let packageversionfunctionvulnsid;
    let dateAdded = datePGFormat(new Date().getTime());
    let sqlString =
      "; INSERT INTO packageversionfunctionvulns(packageversionfunctionid, vulnerability, vulnerabilitypoc, cwe, cves, dateadded) ";
    sqlString += ` Values ('${packageversionfunctionid}', '${vulnerability}', '${vulnerabilitypoc}', '${cwe}', '${cves}', '${dateAdded}')`;
    // sqlString += ` ON CONFLICT on constraint packageversionfunction_unique do UPDATE set dateadded = '${dateAdded}'`;
    sqlString += " RETURNING packageversionfunctionvulnsid;";
    console.log(sqlString);
    //return
    pool.query(sqlString, (err, res) => {
      // console.log(err, res);
      if (err) {
        reject(err);
      }
      packageversionfunctionvulnsid = res.rows[0].packageversionfunctionvulnsid;
      resolve(packageversionfunctionvulnsid);
    });
  });
}

function datePGFormat(stringValue) {
  return new Date().toISOString();
  // var types = pg.types;
  // types.setTypeParser(1114, function (stringValue) {
  //   return new Date(stringValue + "+0000");
  // });
  // return stringValue;
}

// console.log(datePGFormat (new Date().getTime()));
async function zztester() {
  let packageid = await insertPackage(
    "npm",
    "lodash",
    "The Lodash library exported as Node.js modules."
  );
  console.log("packageid", packageid);
  // let packageid = "07cfb129-06f1-487e-b749-b0ad3bf90fbf"
  let packageversionid = await insertPackageVersion(
    packageid,
    "4.17.4",
    "2016-01-12T23:13:20.539Z"
  );
  console.log("packageversionid", packageversionid);

  let packageVersionFunctionId = await insertPackageVersionFunction(
    packageversionid,
    "merge"
  );

  let packageVersionFunctionVulnsId = await insertPackageVersionFunctionVulns(
    packageVersionFunctionId,
    "Prototype pollution",
    "BAD JSON",
    "CWE401",
    "CVE123"
  );
  console.log("packageVersionFunctionVulnsId", packageVersionFunctionVulnsId);
  tearDown();
}
async function tester() {
  let format = "npm";
  let packagename = "lodash";
  let packageid = await getPackageId(format, packagename);
  console.log("packageid", packageid);
  await tearDown();
}
// tester();

async function getPackageId(format, packagename) {
  return new Promise((resolve, reject) => {
    let packageid;
    let sqlString = `SELECT packageid from package where format = '${format}' and packagename = '${packagename}'`;
    console.log(sqlString);
    //return
    pool.query(sqlString, (err, res) => {
      // console.log(err, res);
      if (err) {
        reject(err);
      } else if (res) {
        // console.log(res);
        // console.log("row0", res.rows[0].packageid);
        packageid = res.rows[0].packageid;
      }
      resolve(packageid);
    });
  });
}
exports.insertPackage = insertPackage;
exports.insertPV = insertPV;
exports.insertPVF = insertPVF;
exports.insertPVFV = insertPVFV;
exports.tearDown = tearDown;
exports.getPackageId = getPackageId;
