const fs = require("fs");
const path = require("path");
const util = require("util");
const exec = util.promisify(require("child_process").exec);
const {
  insertPackage,
  insertPV,
  insertPVF,
  insertPVFV,
  tearDown,
  getPackageId,
} = require("./postgres");
let libraries = [
  {
    name: "react",
    rank: 10,
    lastrun: "2020-06-14",
  },
  {
    name: "prop-types",
    rank: 9,
    lastrun: "2020-06-14",
  },
  {
    name: "moment",
    rank: 8,
    lastrun: "2020-06-14",
  },
  {
    name: "express",
    rank: 7,
    lastrun: "2020-06-14",
  },
  {
    name: "request",
    rank: 6,
    lastrun: "2020-06-14",
  },
  {
    name: "lodash",
    rank: 5,
    lastrun: "",
  },
  {
    name: "async",
    rank: 4,
    lastrun: "2020-06-14",
  },
  {
    name: "chalk",
    rank: 3,
    lastrun: "2020-06-14",
  },
  {
    name: "commander",
    rank: 2,
    lastrun: "2020-06-14",
  },
  {
    name: "debug",
    rank: 1,
    lastrun: "2020-06-14",
  },
  {
    name: "@hapi/hoek",
    lastrun: "2020-06-14",
  },
  {
    name: "jquery",
    lastrun: "2020-06-14",
  },
  {
    name: "merge",
    lastrun: "2020-06-14",
  },
  {
    name: "defaults-deep",
    lastrun: "2020-06-14",
  },
  {
    name: "merge-objects",
    lastrun: "2020-06-14",
  },
  {
    name: "assign-deep",
    lastrun: "2020-06-14",
  },
  {
    name: "merge-deep",
    lastrun: "2020-06-14",
  },
  {
    name: "mixin-deep",
    lastrun: "2020-06-14",
  },
  {
    name: "deep-extend",
    lastrun: "2020-06-14",
  },
  {
    name: "merge-options",
    lastrun: "2020-06-14",
  },
  {
    name: "deap",
    lastrun: "2020-06-14",
  },
  {
    name: "merge-recursive",
    lastrun: "2020-06-14",
  },
  {
    name: "pathval",
    lastrun: "2020-06-14",
  },
  {
    name: "dot-prop",
    lastrun: "2020-06-14",
  },
  {
    name: "object-path",
    lastrun: "2020-06-14",
  },
];
async function getAllLibraries() {
  console.log("getAllLibraries starting");
  let rootFolder = process.cwd(); //exploit
  let format = "npm";
  for (const library of libraries.filter((item) => {
    return item.lastrun === "";
  })) {
    let libraryName = library.name;
    console.log(libraryName);
    //get the list of versions for that library
    let packageMetaData = await getPackageData(libraryName);
    console.log(packageMetaData);
    //now create a folder for the Library
    let packageid = await insertPackage(
      format,
      libraryName,
      packageMetaData.package.description
    );
    console.log("packageid", packageid);

    //then create a folder for each version
    //packageMetaData.releases.sort
    for (const packageRelease of packageMetaData.releases) {
      console.log(packageRelease);
      let version = packageRelease.version;
      if (version === "modified" || version === "created") {
        continue;
      }
      let fuzzerResults = await analysePackage(
        rootFolder,
        libraryName,
        version
      );
      console.log("fuzzerResults", fuzzerResults);

      //fuzzerResults.pollution
      if (fuzzerResults) {
        await addPollution(
          format,
          libraryName,
          packageRelease,
          fuzzerResults,
          packageid
        );
      }
      //npm init in each folder
      //npm install the current library version
      //then fuzz it and get a list of vulnerable functions
      //then save the fuzzed data to Postgres
      //then match it to Sonatype CVE Data
    }
  }
  await tearDown();
  console.log("GetAllLibraries finishing");
}
async function addPollution(
  format,
  package,
  packageRelease,
  fuzzerResults,
  packageid
) {
  // let packageid = "07cfb129-06f1-487e-b749-b0ad3bf90fbf"
  let packageversionid = await insertPV(packageid, packageRelease);
  console.log("addPollution packageversionid", packageversionid, fuzzerResults);

  ////////
  //uniqe functions
  function onlyUnique(value, index, self) {
    return (
      self.indexOf(value) === index &&
      value.indexOf("undefined") === -1 &&
      value.indexOf("__proto__") === -1 &&
      value.indexOf("'") === -1
    );
  }
  let uniqueFunctions = fuzzerResults.functions.filter(onlyUnique);
  uniqueFunctions.sort;
  console.log("uniqueFunctions", uniqueFunctions);
  for (const functionName of uniqueFunctions) {
    let packageVersionFunctionId = await insertPVF(
      packageversionid,
      functionName
    );
    const thisPollutedFuncs = fuzzerResults.polluted.filter((item) => {
      return item.functionName === functionName;
    });
    for (const polluted of thisPollutedFuncs) {
      let packageVersionFunctionVulnsId = await insertPVFV(
        packageVersionFunctionId,
        "Prototype pollution",
        polluted.sig,
        "CWE471",
        null
      );
      console.log(
        "packageVersionFunctionVulnsId",
        packageVersionFunctionVulnsId
      );
    }
  }
  ////////
}
async function getPackageData(packagename) {
  const cmd = `npm view ${packagename} --json`;
  const { stdout, stderr } = await exec(cmd, { maxBuffer: 1024 * 1024 });
  let package = JSON.parse(stdout);
  let releases = Object.keys(package.time).map((item, i) => {
    return {
      version: item,
      datePublished: Object.values(package.time)[i],
    };
  });
  return { package: package, releases: releases };
}

async function getVersionHistory(packagename) {
  const cmd = `npm view ${packagename} versions --json`;
  const { stdout, stderr } = await exec(cmd, { maxBuffer: 1024 * 1024 });
  return JSON.parse(stdout);
}

async function analysePackage(rootFolder, packagename, version) {
  console.log(rootFolder, packagename, version);
  process.chdir(rootFolder);
  // const cmd = `pwd`;
  let folder = await createFolder(rootFolder, packagename, version);
  let cnp = await createNodeProject(rootFolder, packagename, version);
  // console.log(cnp);
  const ip = await installPackage(
    rootFolder,
    folder.fullPath,
    packagename,
    version
  );
  console.log("installPackage.result", ip, ip.Error);
  if (ip && ip.Error) {
    return;
  } else {
    //run the fuzzer?
    const libPath = `${folder.fullPath}/node_modules/${packagename}`;
    console.log("Runnnig fuzzer", rootFolder, libPath);
    var fuzzerResults = await fuzzerFunction(rootFolder, libPath);
    return fuzzerResults;
    // return cmd;
  }
}
async function createFolder(rootFolder, packagename, version) {
  process.chdir(rootFolder);
  // const cmd = `pwd`;
  const pck = packagename.replace("/", "_");
  const newFolder = `../npm_libraries/${pck}/v${version}`;
  const fullPath = path.join(rootFolder, newFolder);
  let cmd = `mkdir -p "${fullPath}"`;
  const { stdout, stderr } = await exec(cmd, { maxBuffer: 1024 * 1024 });
  return { fullPath: fullPath, stdout: stdout, stderr: stderr };
}

async function createNodeProject(rootFolder, packagename, version) {
  // console.log(
  //   "createNodeProject begin(rootFolder, packagename, version)",
  //   rootFolder,
  //   packagename,
  //   version
  // );
  const pck = packagename.replace("/", "_");
  const newFolder = `../npm_libraries/${pck}/v${version}`;
  await process.chdir(newFolder);
  // console.log(await process.cwd());
  let cmd;
  // cmd = `npm set init.description fuzzer`;
  // var { stdout, stderr } = await exec(cmd);
  // cmd = `npm set init.repository https://github.com/sonatype-nexus-community/`;
  // var { stdout, stderr } = await exec(cmd);
  cmd = `npm init -y`;
  // console.log(cmd);
  var { stdout, stderr } = await exec(cmd, { maxBuffer: 1024 * 1024 });
  await process.chdir(rootFolder);
  return { cmd: "npm-init", stdout: stdout, stderr: stderr };
}

async function installPackage(rootFolder, fullPath, packagename, version) {
  var cmd;
  var stdout, stderr;
  try {
    console.log(
      "installPackage start(rootFolder, fullPath, packagename, version)",
      rootFolder,
      fullPath,
      packagename,
      version,
      process.cwd()
    );
    await process.chdir(rootFolder);
    await process.chdir(fullPath);
    cmd = `npm install --save --save-exact  ${packagename}@${version}`;

    var { stdout, stderr } = await exec(cmd, { maxBuffer: 1024 * 1024 });
    console.log("exec(cmd);", cmd, stdout, stderr);
  } catch (error) {
    console.log("error", error);
    return { Error: error };
  } finally {
    await process.chdir(rootFolder);
  }
  return { cmd: cmd, stdout: stdout, stderr: stderr };
}

async function reprocess() {
  let rootFolder = process.cwd();
  console.log("rootFolder", rootFolder);
  const format = "npm";

  const { join } = require("path");
  let packagesFolder = path.join(rootFolder, "../npm_libraries/");
  // const allDirs = await getDirectories(packagesFolder);
  for (const library of libraries.filter((item) => {
    return item.lastrun === "";
  })) {
    let packagename = library.name;
    console.log(packagename);
    // for (const packageFolders of allDirs) {
    let packageFolders = packagename.replace("/", "_");
    let subDirectory = join(packagesFolder, packageFolders);
    let packageid = await getPackageId(format, packagename);
    const versionSubDirs = await getDirectories(subDirectory);
    for (const versionFolder of versionSubDirs) {
      const packageVersion = versionFolder.replace("v", "");
      let packageRelease = {
        version: packageVersion,
        datePublished: "2000-01-01 00:00:00.000+00", //dummy date for this reprocess
      };
      const fullFolderPath = path.join(subDirectory, versionFolder);
      const libPath = `${fullFolderPath}/node_modules/${packagename}`;
      console.log("packagename, packageVersion", packagename, packageVersion);
      console.log("Running fuzzer ootFolder, libPath", rootFolder, libPath);
      var fuzzerResults = await fuzzerFunction(
        rootFolder,
        libPath,
        packagename
      );
      if (fuzzerResults) {
        // return;
        await addPollution(
          format,
          packagename,
          packageRelease,
          fuzzerResults,
          packageid
        );
      }
    }
  }
  //this is the top level
  await tearDown();
}

async function zzfuzzerFunction(rootFolder, libPath) {
  //run the fuzzer?
  var fuzzer = require(`${rootFolder}/prototype-pollution-nsec18/find-vuln/find-vuln.js`);
  var fuzzerResults = await fuzzer(libPath);
  console.log(fuzzerResults);
  return fuzzerResults;
}
async function fuzzerFunction(rootFolder, libPath, packagename) {
  console.log("fuzzerFunction", rootFolder, libPath, packagename);
  //output is object fuzzerResults
  let cmd = `node ${rootFolder}/prototype-pollution-nsec18/find-vuln/find-vulnv2.js ${libPath}`;
  console.log("cmd", cmd);
  var { stdout, stderr } = await exec(cmd, { maxBuffer: 1024 * 1024 });
  let results = stdout.split("\n");
  // console.log("results", results);
  // return
  let functions = [];
  let polluted = [];
  for (const func of results) {
    if (func.search("Detected :") > -1) {
      // console.log("func.search(Detected :")
      //add to polluted
      // Detected : /Users/camerontownshend/Documents/Cameron/dev/learnVulnerabilities/prototype-pollution/npm_libraries/lodash/v4.17.14/node_modules/lodash.set (function ({}, BAD_PATH, VALUE))
      let whereName = func.lastIndexOf("/");
      let whereSig = func.indexOf("(");
      let functionName = func.slice(whereName + 1, whereSig - 1);
      let fnct = func;
      let sig = func.slice(whereSig + 1).replace("))", ")");
      let totest = func;
      // if (functionName === packagename) {
      //   functionName = "default";
      // }
      let pollutedItem = {
        name: func, //console.log("Detected : " + name + " (" + sig + ")");
        fnct: fnct,
        sig: sig,
        totest: totest,
        functionName: functionName,
      };
      uniqueAdd(functions, functionName);
      uniqueAddSig(polluted, pollutedItem);
    } else {
      uniqueAdd(functions, func);
    }
  }
  return {
    polluted: polluted,
    functions: functions,
  };
  // console.log(stdout);
}
function uniqueAdd(arr, item) {
  if (item && arr.indexOf(item) === -1) {
    arr.push(item);
    // console.log(arr);
  }
}

function uniqueAddSig(arr, item) {
  if (
    arr.filter((arrItem) => {
      return (
        arrItem.sig === item.sig && arrItem.functionName === item.functionName
      );
    }).length === 0
  ) {
    arr.push(item);
  }
  // if (arr.indexOf(item) === -1) {
  //   arr.push(item);
  //   // console.log(arr);
  // }
}
async function getDirectories(path) {
  return fs.readdirSync(path).filter(function (file) {
    return fs.statSync(path + "/" + file).isDirectory();
  });
}
async function tester() {}

// tester();
// parseElement();
getAllLibraries();

// reprocess();
